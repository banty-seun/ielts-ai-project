import React, { useState, useEffect } from 'react';
import { useRoute, Link as WouterLink } from 'wouter';
import { ChevronLeft, Play, Pause, RotateCcw, Volume2, AlignLeft, CheckCircle } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Progress } from '@/components/ui/progress';
import { Textarea } from '@/components/ui/textarea';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { ProtectedRoute } from '@/components/ProtectedRoute';
import { cn } from '@/lib/utils';

// Mock data for the initial implementation
// These will be replaced with actual data from the API
interface QuestionOption {
  id: string;
  text: string;
}

interface BlankOption {
  id: string;
  text: string;
}

interface Blank {
  id: string;
  options: BlankOption[];
  correctAnswer: string;
}

interface Question {
  id: string;
  text: string;
  type: 'multiple-choice' | 'fill-in-the-gap' | 'fill-in-multiple-gaps';
  options?: QuestionOption[];
  correctAnswer?: string; // For multiple-choice and single fill-in-the-gap
  blanks?: Blank[]; // For fill-in-multiple-gaps
  explanation?: string; // Explanation of the answer for feedback
  hint?: string; // Hint for next time
}

// Component for multiple choice questions
const MultipleChoiceQuestion = ({ 
  question, 
  selectedAnswer, 
  onSelectAnswer,
  isSubmitted
}: { 
  question: Question; 
  selectedAnswer: string | null;
  onSelectAnswer: (answerId: string) => void;
  isSubmitted: boolean;
}) => {
  if (!question.options) return null;
  
  return (
    <div className="my-6">
      <p className="font-medium mb-3">{question.text}</p>
      <RadioGroup 
        value={selectedAnswer || ""}
        onValueChange={(value) => !isSubmitted && onSelectAnswer(value)}
        className="space-y-3"
      >
        {question.options.map((option) => {
          const isCorrect = isSubmitted && option.id === question.correctAnswer;
          const isIncorrect = isSubmitted && selectedAnswer === option.id && option.id !== question.correctAnswer;
          
          return (
            <div key={option.id} className="flex items-center space-x-2">
              <RadioGroupItem 
                value={option.id} 
                id={option.id} 
                disabled={isSubmitted}
                className={cn(
                  isCorrect && "border-green-500 text-green-500",
                  isIncorrect && "border-red-500 text-red-500"
                )}
              />
              <Label 
                htmlFor={option.id}
                className={cn(
                  "cursor-pointer",
                  isCorrect && "text-green-500 font-medium",
                  isIncorrect && "text-red-500 font-medium line-through"
                )}
              >
                {option.text}
              </Label>
              {isCorrect && (
                <CheckCircle className="h-4 w-4 text-green-500 ml-2" />
              )}
            </div>
          );
        })}
      </RadioGroup>
    </div>
  );
};

// Component for fill-in-the-gap questions
const FillInTheGapQuestion = ({ 
  question, 
  answer, 
  onAnswerChange,
  isSubmitted
}: { 
  question: Question; 
  answer: string;
  onAnswerChange: (text: string) => void;
  isSubmitted: boolean;
}) => {
  return (
    <div className="my-6">
      <p className="font-medium mb-3">{question.text}</p>
      <div className="mt-2">
        <Textarea 
          placeholder="Type your answer here..."
          value={answer}
          onChange={(e) => !isSubmitted && onAnswerChange(e.target.value)}
          disabled={isSubmitted}
          className={cn(
            "resize-none h-20",
            isSubmitted && (
              answer === question.correctAnswer 
                ? "border-green-500 focus-visible:ring-green-500" 
                : "border-red-500 focus-visible:ring-red-500"
            )
          )}
        />
        
        {isSubmitted && (
          <div className="mt-3">
            <p className={cn(
              "text-sm font-medium",
              answer === question.correctAnswer ? "text-green-600" : "text-red-600"
            )}>
              {answer === question.correctAnswer 
                ? "Correct!" 
                : `Incorrect. The correct answer is: ${question.correctAnswer}`}
            </p>
          </div>
        )}
      </div>
    </div>
  );
};

// Type guard for multiple gaps questions
interface MultipleGapsQuestion extends Omit<Question, 'type' | 'blanks'> {
  type: 'fill-in-multiple-gaps';
  blanks: Blank[];
}

function isMultipleGapsQuestion(question: Question): question is MultipleGapsQuestion {
  return question.type === 'fill-in-multiple-gaps' && !!question.blanks;
}

// Component for fill-in-multiple-gaps questions
const FillInMultipleGapsQuestion = ({ 
  question, 
  answers, 
  onAnswerChange,
  isSubmitted
}: { 
  question: MultipleGapsQuestion;
  answers: Record<string, string>;
  onAnswerChange: (blankId: string, value: string) => void;
  isSubmitted: boolean;
}) => {
  // Create a map of blanks for easier access
  const blanksMap: { [key: string]: Blank } = {};
  question.blanks.forEach(blank => {
    blanksMap[blank.id] = blank;
  });
  
  return (
    <div className="my-6">
      <p className="font-medium mb-3">{question.text}</p>
      <div className="space-y-4 mt-2">
        {question.blanks.map((blank) => (
          <div key={blank.id}>
            <p className="text-sm mb-2">{blank.id}:</p>
            <RadioGroup 
              value={answers[blank.id] || ""}
              onValueChange={(value) => !isSubmitted && onAnswerChange(blank.id, value)}
              className="space-y-2"
            >
              {blank.options.map((option) => {
                const isCorrect = isSubmitted && option.id === blank.correctAnswer;
                const isIncorrect = isSubmitted && answers[blank.id] === option.id && option.id !== blank.correctAnswer;
                
                return (
                  <div key={option.id} className="flex items-center space-x-2">
                    <RadioGroupItem 
                      value={option.id} 
                      id={`${blank.id}-${option.id}`} 
                      disabled={isSubmitted}
                      className={cn(
                        isCorrect && "border-green-500 text-green-500",
                        isIncorrect && "border-red-500 text-red-500"
                      )}
                    />
                    <Label 
                      htmlFor={`${blank.id}-${option.id}`}
                      className={cn(
                        "cursor-pointer",
                        isCorrect && "text-green-500 font-medium",
                        isIncorrect && "text-red-500 font-medium line-through"
                      )}
                    >
                      {option.text}
                    </Label>
                    {isCorrect && (
                      <CheckCircle className="h-4 w-4 text-green-500 ml-2" />
                    )}
                  </div>
                );
              })}
            </RadioGroup>
          </div>
        ))}
      </div>
      
      {isSubmitted && (
        <div className="mt-4">
          <p className="text-sm font-medium">Answers:</p>
          <ul className="list-disc list-inside pl-2 mt-1 space-y-1 text-sm">
            {question.blanks.map((blank) => {
              const correctOption = blank.options.find(o => o.id === blank.correctAnswer);
              const userOption = blank.options.find(o => o.id === answers[blank.id]);
              const isCorrect = answers[blank.id] === blank.correctAnswer;
              
              return (
                <li key={blank.id} className={isCorrect ? "text-green-600" : "text-red-600"}>
                  {blank.id}: {userOption ? userOption.text : "No answer"} 
                  {!isCorrect && (
                    <span className="text-green-600"> (Correct: {correctOption?.text})</span>
                  )}
                </li>
              );
            })}
          </ul>
          
          {question.explanation && (
            <div className="mt-2">
              <p className="text-sm font-medium mb-1">Explanation:</p>
              <p className="text-sm">{question.explanation}</p>
            </div>
          )}
          
          {question.hint && (
            <div className="mt-2">
              <p className="text-sm font-medium mb-1">Hint for next time:</p>
              <p className="text-sm italic">{question.hint}</p>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// Define an interface for our exercise set
interface ExerciseSet {
  id: string;
  title: string;
  accent: 'British' | 'Canadian' | 'American' | 'Australian';
  audioUrl: string;
  audioDuration: number;
  questions: Question[];
}

// Interface for exercise results
interface ExerciseResult {
  exerciseId: string;
  score: number;
  totalQuestions: number;
  completed: boolean;
  timestamp: number;
}

// Function to calculate the total score across exercise history
function calculateTotalScore(history: ExerciseResult[]): { score: number, total: number } {
  return history.reduce((acc, result) => {
    return {
      score: acc.score + result.score,
      total: acc.total + result.totalQuestions
    };
  }, { score: 0, total: 0 });
}

// Main Practice component
const Practice = () => {
  // Extract week and day from the route
  const [match, params] = useRoute('/practice/:week/:day');
  const week = params?.week || '1';
  const day = params?.day || '1';

  // Get query parameters
  const searchParams = new URLSearchParams(window.location.search);
  const originalTitle = searchParams.get('title') || 'Listening Practice';
  const skill = searchParams.get('skill') || 'Listening';
  const originalAccent = searchParams.get('accent') || 'British'; // Extract accent from URL or use default
  
  // Audio player state
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(80);
  const [replaysRemaining, setReplaysRemaining] = useState(2); // For the replay limiter feature
  
  // Session timer state (for overall practice duration from user preferences)
  const [sessionDurationMinutes, setSessionDurationMinutes] = useState(30); // Default 30 minutes
  const [sessionTimeRemaining, setSessionTimeRemaining] = useState(sessionDurationMinutes * 60); // Convert to seconds
  const [sessionTimerActive, setSessionTimerActive] = useState(true);
  const [sessionComplete, setSessionComplete] = useState(false);
  
  // Exercise timer state (for individual exercise)
  const [exerciseTimeRemaining, setExerciseTimeRemaining] = useState(120); // 2 minutes in seconds
  const [exerciseTimerActive, setExerciseTimerActive] = useState(false);
  const [exerciseTimerExpired, setExerciseTimerExpired] = useState(false);
  
  // Questions navigation state
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  
  // Mock data for multiple listening clips
  const exerciseSets: ExerciseSet[] = [
    {
      id: 'exercise-1',
      title: 'Office Dialogue: Job Interview',
      accent: 'British',
      audioUrl: '', // Will be replaced with real audio files
      audioDuration: 120, // 2 minutes
      questions: [
        {
          id: '1',
          text: 'What is the main topic discussed in the audio?',
          type: 'multiple-choice',
          options: [
            { id: 'a', text: 'Canadian immigration policies' },
            { id: 'b', text: 'Housing market in Canada' },
            { id: 'c', text: 'Employment opportunities for newcomers' },
            { id: 'd', text: 'Education system for immigrants' }
          ],
          correctAnswer: 'c',
          explanation: 'The speaker primarily focuses on employment challenges and opportunities for newcomers to Canada, including statistics and growth sectors.',
          hint: 'Pay attention to repeated themes and statistical information that the speaker emphasizes.'
        },
        {
          id: '2',
          text: 'According to the speaker, the unemployment rate for new immigrants in Canada is ______.',
          type: 'fill-in-the-gap',
          correctAnswer: '11.5 percent',
          explanation: 'The speaker explicitly mentions this statistic when comparing employment rates between new immigrants and Canadian-born citizens.',
          hint: 'Listen for specific numerical data points, especially when comparisons are being made.'
        },
        {
          id: '3',
          text: 'Complete the following sentence from the audio: The three fastest growing sectors for immigrant employment in Canada are [BLANK_1], [BLANK_2], and [BLANK_3].',
          type: 'fill-in-multiple-gaps',
          blanks: [
            {
              id: 'BLANK_1',
              options: [
                { id: 'a', text: 'technology' },
                { id: 'b', text: 'agriculture' },
                { id: 'c', text: 'manufacturing' },
                { id: 'd', text: 'retail' }
              ],
              correctAnswer: 'a'
            },
            {
              id: 'BLANK_2',
              options: [
                { id: 'a', text: 'education' },
                { id: 'b', text: 'healthcare' },
                { id: 'c', text: 'transportation' },
                { id: 'd', text: 'construction' }
              ],
              correctAnswer: 'b'
            },
            {
              id: 'BLANK_3',
              options: [
                { id: 'a', text: 'finance' },
                { id: 'b', text: 'hospitality' },
                { id: 'c', text: 'skilled trades' },
                { id: 'd', text: 'energy' }
              ],
              correctAnswer: 'c'
            }
          ],
          explanation: 'The speaker lists these three sectors as having the highest growth and best opportunities for new immigrants to Canada.',
          hint: 'Try to identify lists or enumerations in the audio and write down each item as you hear it.'
        }
      ]
    },
    {
      id: 'exercise-2',
      title: 'Workplace Communication: Team Meeting',
      accent: 'Canadian',
      audioUrl: '', // Will be replaced with real audio files
      audioDuration: 120, // 2 minutes
      questions: [
        {
          id: '1',
          text: 'What is the main purpose of the team meeting discussed in the audio?',
          type: 'multiple-choice',
          options: [
            { id: 'a', text: 'Planning the annual budget' },
            { id: 'b', text: 'Discussing a new project timeline' },
            { id: 'c', text: 'Introducing new team members' },
            { id: 'd', text: 'Reviewing customer feedback' }
          ],
          correctAnswer: 'b',
          explanation: 'The main speaker clearly outlines the purpose of adjusting the project timeline due to new client requirements.',
          hint: 'Focus on the opening statements where the meeting agenda is typically presented.'
        },
        {
          id: '2',
          text: 'According to the project manager, the new deadline for the project is ______.',
          type: 'fill-in-the-gap',
          correctAnswer: 'March 15th',
          explanation: 'The project manager explicitly mentions this new deadline after discussing the timeline adjustment.',
          hint: 'Listen for specific dates mentioned in the context of deadlines or milestones.'
        }
      ]
    }
  ];

  // Questions and answers state
  const [currentExerciseIndex, setCurrentExerciseIndex] = useState(0);
  const [exerciseHistory, setExerciseHistory] = useState<ExerciseResult[]>([]);
  
  // Get the current exercise
  const currentExercise = exerciseSets[currentExerciseIndex];
  const [questions, setQuestions] = useState<Question[]>(currentExercise.questions);
  
  const [answers, setAnswers] = useState<Record<string, string>>({});
  const [multiGapAnswers, setMultiGapAnswers] = useState<Record<string, Record<string, string>>>({});
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [feedback, setFeedback] = useState('');
  const [showCompletionSummary, setShowCompletionSummary] = useState(false);
  
  // Current question for single question navigation
  const currentQuestion = questions[currentQuestionIndex];
  
  // Handle answer changes for multiple choice and fill-in-the-gap questions
  const handleSelectAnswer = (questionId: string, answerId: string) => {
    setAnswers(prev => ({
      ...prev,
      [questionId]: answerId
    }));
  };
  
  const handleTextAnswer = (questionId: string, text: string) => {
    setAnswers(prev => ({
      ...prev,
      [questionId]: text
    }));
  };
  
  // Handle answer changes for fill-in-multiple-gaps questions
  const handleMultiGapAnswer = (questionId: string, blankId: string, value: string) => {
    setMultiGapAnswers(prev => ({
      ...prev,
      [questionId]: {
        ...(prev[questionId] || {}),
        [blankId]: value
      }
    }));
  };
  
  // Question navigation
  const goToNextQuestion = () => {
    if (currentQuestionIndex < questions.length - 1) {
      setCurrentQuestionIndex(prev => prev + 1);
    }
  };
  
  const goToPreviousQuestion = () => {
    if (currentQuestionIndex > 0) {
      setCurrentQuestionIndex(prev => prev - 1);
    }
  };
  
  // Check if current question is answered
  const isCurrentQuestionAnswered = () => {
    if (!currentQuestion) return false;
    
    if (isMultipleGapsQuestion(currentQuestion)) {
      if (!multiGapAnswers[currentQuestion.id]) return false;
      return currentQuestion.blanks.every(blank => 
        multiGapAnswers[currentQuestion.id][blank.id]
      );
    }
    
    return !!answers[currentQuestion.id];
  };
  
  // Check if all questions are answered
  const areAllQuestionsAnswered = () => {
    return questions.every(q => {
      if (isMultipleGapsQuestion(q)) {
        if (!multiGapAnswers[q.id]) return false;
        return q.blanks.every(blank => multiGapAnswers[q.id][blank.id]);
      }
      return !!answers[q.id];
    });
  };
  
  // Calculate the score for the current exercise
  const calculateScore = (): number => {
    let score = 0;
    
    questions.forEach(question => {
      if (isMultipleGapsQuestion(question)) {
        if (multiGapAnswers[question.id]) {
          const allBlanksCorrect = question.blanks.every(blank => 
            multiGapAnswers[question.id][blank.id] === blank.correctAnswer
          );
          if (allBlanksCorrect) score++;
        }
      } else {
        if (answers[question.id] === question.correctAnswer) {
          score++;
        }
      }
    });
    
    return score;
  };
  
  // Get total possible score from exercise history
  const getTotalScore = () => {
    return exerciseHistory.reduce((total, exercise) => total + exercise.score, 0);
  };
  
  // Get total questions attempted from exercise history
  const getTotalPossibleScore = () => {
    return exerciseHistory.reduce((total, exercise) => total + exercise.totalQuestions, 0);
  };
  
  // Handle submission
  const handleSubmit = () => {
    setIsSubmitted(true);
    setExerciseTimerActive(false);
    
    // Calculate score
    const score = calculateScore();
    
    // Record exercise history
    const result: ExerciseResult = {
      exerciseId: currentExercise.id,
      score,
      totalQuestions: questions.length,
      completed: true,
      timestamp: Date.now()
    };
    
    setExerciseHistory(prev => [...prev, result]);
    
    // Generate feedback
    setFeedback(`You scored ${score} out of ${questions.length} questions correctly. ${score === questions.length ? 'Great job!' : 'Keep practicing to improve your listening skills.'}`);
  };
  
  // Handle moving to the next exercise
  const handleNextExercise = () => {
    // Check if there are more exercises
    if (currentExerciseIndex < exerciseSets.length - 1) {
      // Go to next exercise
      setCurrentExerciseIndex(prev => prev + 1);
      
      // Reset exercise state
      setIsSubmitted(false);
      setAnswers({});
      setMultiGapAnswers({});
      setFeedback('');
      setCurrentTime(0);
      setIsPlaying(false);
      setExerciseTimeRemaining(120);
      setExerciseTimerActive(false);
      setExerciseTimerExpired(false);
      setCurrentQuestionIndex(0);
      setReplaysRemaining(2);
    } else {
      // No more exercises, show completion summary
      setShowCompletionSummary(true);
    }
  };
  
  // Handle reset for trying the same exercise again
  const handleReset = () => {
    setIsSubmitted(false);
    setAnswers({});
    setMultiGapAnswers({});
    setFeedback('');
    setCurrentTime(0);
    setIsPlaying(false);
    setExerciseTimeRemaining(120);
    setExerciseTimerActive(false);
    setExerciseTimerExpired(false);
    setCurrentQuestionIndex(0);
    setReplaysRemaining(2);
  };
  
  // Format time for display (mm:ss)
  const formatTime = (seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
  };
  
  // Exercise timer countdown
  useEffect(() => {
    let interval: NodeJS.Timeout;
    
    if (exerciseTimerActive && exerciseTimeRemaining > 0 && !isSubmitted) {
      interval = setInterval(() => {
        setExerciseTimeRemaining(prev => prev - 1);
      }, 1000);
    } else if (exerciseTimeRemaining === 0 && !exerciseTimerExpired) {
      setExerciseTimerExpired(true);
      // Don't auto-submit when exercise timer expires
    }
    
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [exerciseTimerActive, exerciseTimeRemaining, exerciseTimerExpired, isSubmitted]);
  
  // Start exercise timer when audio plays
  useEffect(() => {
    if (isPlaying && !exerciseTimerActive && !isSubmitted) {
      setExerciseTimerActive(true);
    }
  }, [isPlaying, exerciseTimerActive, isSubmitted]);
  
  // Session timer countdown
  useEffect(() => {
    let interval: NodeJS.Timeout;
    
    if (sessionTimerActive && sessionTimeRemaining > 0 && !sessionComplete) {
      interval = setInterval(() => {
        setSessionTimeRemaining(prev => prev - 1);
      }, 1000);
    } else if (sessionTimeRemaining === 0 && !sessionComplete) {
      setSessionComplete(true);
      
      // Time's up for the entire session
      setFeedback(`Time's up for today. Great work! You completed ${exerciseHistory.length} exercises with a total score of ${getTotalScore()} out of ${getTotalPossibleScore()}. Come back tomorrow to continue your progress.`);
      setShowCompletionSummary(true);
    }
    
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [sessionTimerActive, sessionTimeRemaining, sessionComplete, exerciseHistory]);
  
  // TODO: Connect to actual audio player when audio files are available
  // For now, simulate audio player progress
  useEffect(() => {
    let interval: NodeJS.Timeout;
    
    if (isPlaying && currentTime < 120) {
      interval = setInterval(() => {
        setCurrentTime(prev => {
          const newTime = prev + 1;
          if (newTime >= 120) {
            setIsPlaying(false);
            return 120;
          }
          return newTime;
        });
      }, 1000);
    }
    
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isPlaying, currentTime]);
  
  // Set simulated duration
  useEffect(() => {
    setDuration(currentExercise.audioDuration);
    
    // Update questions when current exercise changes
    setQuestions(currentExercise.questions);
  }, [currentExercise]);
  
  // Handle audio replay with limited replays
  const handlePlayPause = () => {
    // If audio is finished, restart it
    if (currentTime >= duration) {
      if (replaysRemaining > 0 && !isSubmitted) {
        setCurrentTime(0);
        setIsPlaying(true);
        setReplaysRemaining(prev => prev - 1);
      }
    } else {
      // Toggle play/pause if still playing
      setIsPlaying(!isPlaying);
    }
  };
  
  // Handle audio reset with replay limit
  const handleResetAudio = () => {
    if (replaysRemaining > 0 && !isSubmitted) {
      setCurrentTime(0);
      setIsPlaying(false);
      setReplaysRemaining(prev => prev - 1);
    }
  };
  
  // Session completion summary view
  if (showCompletionSummary) {
    const { score, total } = calculateTotalScore(exerciseHistory);
    const percentageScore = total > 0 ? Math.round((score / total) * 100) : 0;
    
    return (
      <div className="max-w-4xl mx-auto px-4 py-8">
        <div className="mb-6">
          <WouterLink href="/dashboard" className="flex items-center text-sm text-gray-600 hover:text-gray-900">
            <ChevronLeft className="h-4 w-4 mr-1" />
            Back to Dashboard
          </WouterLink>
        </div>
        
        <Card>
          <CardHeader>
            <CardTitle>Session Complete</CardTitle>
            <CardDescription>
              {sessionComplete 
                ? "Time's up for today. Great work!" 
                : "You've completed all exercises for today."}
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="flex flex-col items-center justify-center p-6 bg-gray-50 rounded-lg">
              <h3 className="text-xl font-bold mb-2">Your Score</h3>
              <div className="text-4xl font-bold mb-2">{score}/{total}</div>
              <div className="text-lg">{percentageScore}%</div>
            </div>
            
            <div>
              <h3 className="text-lg font-medium mb-2">Exercises Completed</h3>
              <ul className="space-y-2">
                {exerciseHistory.map((result, index) => (
                  <li key={index} className="p-3 bg-gray-50 rounded-md">
                    <div className="flex justify-between items-center">
                      <span>Exercise {index + 1}</span>
                      <Badge className={result.score === result.totalQuestions ? "bg-green-100 text-green-800" : "bg-gray-100"}>
                        {result.score}/{result.totalQuestions}
                      </Badge>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
            
            <div>
              <h3 className="text-lg font-medium mb-2">Feedback</h3>
              <p>
                {percentageScore >= 80 
                  ? "Excellent work! You show a good understanding of listening comprehension."
                  : percentageScore >= 60
                    ? "Good progress. Continue practicing to improve your listening skills."
                    : "Keep practicing regularly to build your listening skills."
                }
              </p>
            </div>
          </CardContent>
          <CardFooter>
            <Button 
              className="w-full bg-black text-white hover:bg-gray-800"
              onClick={() => window.location.href = '/dashboard'}
            >
              Return to Dashboard
            </Button>
          </CardFooter>
        </Card>
      </div>
    );
  }
  
  return (
    <div className="max-w-4xl mx-auto px-4 py-8">
      <div className="mb-6">
        <WouterLink href="/dashboard" className="flex items-center text-sm text-gray-600 hover:text-gray-900">
          <ChevronLeft className="h-4 w-4 mr-1" />
          Back to Dashboard
        </WouterLink>
      </div>
      
      <div className="mb-4 flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold mb-1">{currentExercise.title}</h1>
          <div className="flex items-center gap-2">
            <Badge variant="outline" className="text-xs">Week {week}</Badge>
            <Badge variant="outline" className="text-xs">Day {day}</Badge>
            <Badge className="bg-black text-white text-xs">{skill}</Badge>
          </div>
        </div>
        <div className="font-medium text-sm">
          Session time: {formatTime(sessionTimeRemaining)}
        </div>
      </div>
      
      <Card className="mb-8">
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center gap-2">
              <Volume2 className="h-5 w-5" />
              Audio Player
            </CardTitle>
            <Badge variant="outline" className="bg-gray-100">
              {currentExercise.accent} Accent
            </Badge>
          </div>
          <CardDescription>
            Listen carefully to the audio and answer the questions.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div className="flex items-center gap-2">
              <Button 
                variant="outline" 
                size="icon"
                onClick={handlePlayPause}
                disabled={(currentTime >= duration && replaysRemaining === 0) || isSubmitted}
              >
                {isPlaying ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
              </Button>
              <Button 
                variant="outline" 
                size="icon"
                onClick={handleResetAudio}
                disabled={replaysRemaining === 0 || isSubmitted}
              >
                <RotateCcw className="h-4 w-4" />
              </Button>
              <div className="flex-1 ml-2">
                <div className="flex justify-between text-xs text-gray-500 mb-1">
                  <span>{formatTime(currentTime)}</span>
                  <span>{formatTime(duration)}</span>
                </div>
                <Progress value={(currentTime / duration) * 100} />
              </div>
            </div>
            
            <div className="flex items-center justify-between mt-2">
              <div className="text-xs text-gray-500">
                {replaysRemaining > 0 ? 
                  `${replaysRemaining} replay${replaysRemaining !== 1 ? 's' : ''} remaining` : 
                  'No replays remaining'}
              </div>
              <div className="font-medium text-sm">
                Exercise time: {formatTime(exerciseTimeRemaining)}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
      
      <div className="mb-6 flex items-center justify-between">
        <div className="flex items-center gap-1">
          <p className="text-sm font-medium">Question {currentQuestionIndex + 1} of {questions.length}</p>
          <Progress 
            className="w-24 h-2 ml-2"
            value={((currentQuestionIndex + 1) / questions.length) * 100} 
          />
        </div>
        <div className="flex gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={goToPreviousQuestion}
            disabled={currentQuestionIndex === 0}
          >
            Previous
          </Button>
          <Button
            variant="outline"
            size="sm"
            onClick={goToNextQuestion}
            disabled={currentQuestionIndex === questions.length - 1}
          >
            Next
          </Button>
        </div>
      </div>
      
      <Card className="mb-8">
        <CardContent className="pt-6">
          {currentQuestion.type === 'multiple-choice' && (
            <MultipleChoiceQuestion 
              question={currentQuestion}
              selectedAnswer={answers[currentQuestion.id] || null}
              onSelectAnswer={(answerId) => handleSelectAnswer(currentQuestion.id, answerId)}
              isSubmitted={isSubmitted}
            />
          )}
          
          {currentQuestion.type === 'fill-in-the-gap' && (
            <FillInTheGapQuestion 
              question={currentQuestion}
              answer={answers[currentQuestion.id] || ''}
              onAnswerChange={(text) => handleTextAnswer(currentQuestion.id, text)}
              isSubmitted={isSubmitted}
            />
          )}
          
          {isMultipleGapsQuestion(currentQuestion) && (
            <FillInMultipleGapsQuestion 
              question={currentQuestion}
              answers={multiGapAnswers[currentQuestion.id] || {}}
              onAnswerChange={(blankId, value) => handleMultiGapAnswer(currentQuestion.id, blankId, value)}
              isSubmitted={isSubmitted}
            />
          )}
        </CardContent>
        <CardFooter className="flex justify-end">
          {!isSubmitted ? (
            <Button 
              className="bg-black text-white hover:bg-gray-800"
              onClick={handleSubmit}
              disabled={!areAllQuestionsAnswered()}
            >
              Submit Answers
            </Button>
          ) : (
            <div className="flex gap-2">
              <Button 
                variant="outline"
                onClick={handleReset}
              >
                Try Again
              </Button>
              <Button 
                className="bg-black text-white hover:bg-gray-800"
                onClick={handleNextExercise}
              >
                Continue to Next Exercise
              </Button>
            </div>
          )}
        </CardFooter>
      </Card>
      
      {isSubmitted && (
        <>
          <Card className="mb-8">
            <CardHeader>
              <CardTitle>Your Results</CardTitle>
              <CardDescription>
                Review your answers and see explanations for each question
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-8">
              {questions.map((question, index) => {
                // Determine if the question was answered correctly
                const isCorrect = 
                  isMultipleGapsQuestion(question) ?
                    question.blanks.every(blank => 
                      (multiGapAnswers[question.id]?.[blank.id] || '') === blank.correctAnswer
                    ) :
                    (answers[question.id] || '') === question.correctAnswer;
                
                return (
                  <div key={question.id} className="pb-6 border-b border-gray-100 last:border-b-0 last:pb-0">
                    <div className="flex items-center gap-2 mb-3">
                      <h3 className="text-lg font-medium">Question {index + 1}</h3>
                      <Badge className={isCorrect ? "bg-green-100 text-green-800" : "bg-red-100 text-red-800"}>
                        {isCorrect ? "Correct" : "Incorrect"}
                      </Badge>
                    </div>
                    
                    <p className="mb-3">{question.text}</p>
                    
                    {isMultipleGapsQuestion(question) ? (
                      <div className="mb-4">
                        <p className="text-sm font-medium mb-2">Your answer:</p>
                        <ul className="list-disc list-inside pl-2 space-y-1 text-sm">
                          {question.blanks.map(blank => {
                            const userAnswer = multiGapAnswers[question.id]?.[blank.id] || '';
                            const option = blank.options.find(opt => opt.id === userAnswer);
                            const correctOption = blank.options.find(opt => opt.id === blank.correctAnswer);
                            const isBlankCorrect = userAnswer === blank.correctAnswer;
                            
                            return (
                              <li key={blank.id} className={cn(
                                isBlankCorrect ? "text-green-700" : "text-red-700"
                              )}>
                                <span className="font-medium">{blank.id}: </span>
                                <span>
                                  {option?.text || "No answer"} 
                                  {!isBlankCorrect && correctOption && (
                                    <span className="text-green-700"> (Correct: {correctOption.text})</span>
                                  )}
                                </span>
                              </li>
                            );
                          })}
                        </ul>
                      </div>
                    ) : (
                      <div className="mb-4">
                        <p className="text-sm font-medium mb-2">Your answer:</p>
                        <p className={cn(
                          "text-sm pl-2",
                          isCorrect ? "text-green-700" : "text-red-700"
                        )}>
                          {question.type === 'multiple-choice' ? (
                            question.options?.find(opt => opt.id === answers[question.id])?.text || "No answer"
                          ) : (
                            answers[question.id] || "No answer"
                          )}
                          
                          {!isCorrect && (
                            <span className="text-green-700 ml-2">
                              (Correct: {
                                question.type === 'multiple-choice' 
                                  ? question.options?.find(opt => opt.id === question.correctAnswer)?.text 
                                  : question.correctAnswer
                              })
                            </span>
                          )}
                        </p>
                      </div>
                    )}
                    
                    {question.explanation && (
                      <div className="mb-3">
                        <p className="text-sm font-medium mb-1">Explanation:</p>
                        <p className="text-sm pl-2">{question.explanation}</p>
                      </div>
                    )}
                    
                    {question.hint && (
                      <div>
                        <p className="text-sm font-medium mb-1">Hint for next time:</p>
                        <p className="text-sm italic pl-2">{question.hint}</p>
                      </div>
                    )}
                  </div>
                );
              })}
            </CardContent>
          </Card>
          
          {feedback && (
            <Card>
              <CardHeader>
                <CardTitle>AI Feedback</CardTitle>
                <CardDescription>
                  Here's personalized feedback on your performance
                </CardDescription>
              </CardHeader>
              <CardContent>
                <p>{feedback}</p>
              </CardContent>
              <CardFooter>
                <Button 
                  onClick={handleReset}
                  className="mr-4"
                  variant="outline"
                >
                  Try Again
                </Button>
                <Button 
                  className="bg-black text-white hover:bg-gray-800"
                  onClick={handleNextExercise}
                >
                  Continue to Next Exercise
                </Button>
              </CardFooter>
            </Card>
          )}
        </>
      )}
    </div>
  );
};

export default function PracticePage() {
  return (
    <ProtectedRoute requireOnboarding>
      <Practice />
    </ProtectedRoute>
  );
}